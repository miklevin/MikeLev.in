---
title: The Necessity of Taking Multiple Small Passes (Chisel-strikes)
permalink: /futureproof/multiple-passes/
description: 
layout: post
sort_order: 1
---

You're not going to get there right away. It takes multiple passes. Each pass is
a little refinement. Only so much can fit in a 24-hour day, and as I learned
recently, trying to push yourself significantly beyond that is going to result
in a kind of crash with your body rejecting, and a phase of catch-up as your
body demands the sleep it needs to function, and maybe a little bit more.

The pendulum swings both ways, and if you somehow find the energy to double-down
and focus, finding enough love (or urgency or whatever) in what you do to bear
down and give it greater-than-normal amount of work it takes to get done, maybe
for consecutive days and maybe at the expense of other things, then you might
achieve that goal but there is a toll to pay.

It can be worth doing, if the accomplishment is of the sort that is forever with
you and somehow forever improves your life. Getting over that initial hurdle to
learn the vim text editor is a lot like that. Deep startup cost that's going to
take some extra effort up-front, but over time it won't stop paying off and so
was worth doing in the first place. The last article was about banking wins.

So we've got something like a prescribed rhythm developing here. On occasions in
your life when you have to put a herculean effort behind something, it's okay to
clear your calendar and your mind and bear down with that single-minded
determination to get it done. But don't do this too often in your life, because
it's the initial out-of-balance startup cost that your body can't take you
paying too often. Be kind to yourself. 

But then you have to keep tension in the machinery. Letting up for too long will
cause a backsliding and loss of forward progress and momentum. Skills fade, so
if you're focusing on a skill that you want to keep and keep sharp, you then
enter a phase of daily chisel-strikes. Or multiple chisel-strikes per day, each
chisel-strike some sort of no-takebacks banked accomplishment.

Lather, rinse, repeat, and you might have something. Maybe not. Your entire
original premise or belief that this is even the skill you wanted might be
wrong, and it probably does take about 10 years or 10,000 hours to master a
skill as that... what's that guideline? Perplexity?

**Perplexity**: The 10,000-hour rule, popularized by Malcolm Gladwell in his book "Outliers," suggests that it takes approximately 10,000 hours of practice to achieve mastery in a complex skill[1][2]. This equates to roughly 10 years of dedicated practice, assuming about 20 hours per week[3].

However, it's important to note several key points about this guideline:

1. Quality of practice matters: The rule emphasizes deliberate, focused practice under the guidance of an expert or skilled coach, not just any kind of practice[5][7].

2. It's an average, not a fixed rule: The actual time required can vary significantly between individuals and fields[7].

3. It applies to complex skills: Simpler skills may require less time to master[6].

4. Practice is not the only factor: While important, practice accounts for only about 20-25% of skill variation in various fields[7].

5. Other factors matter: Age, genetics, and quality of instruction also play significant roles in skill development[7].

Recent research has shown that the 10,000-hour rule is more of a general guideline than a strict rule. The time required to achieve mastery can range from 728 to 16,120 hours, depending on the individual and the field[7].

In essence, while extensive practice is crucial for developing expertise, the "10,000-hour rule" should be viewed as a simplified representation of the dedication and effort required to master a complex skill, rather than a precise formula for success[8].

Citations:

    [1] https://www.reddit.com/r/getdisciplined/comments/hklia6/method_if_you_follow_the_10000_hour_rule_life/
    [2] https://www.followyourbuyer.com/doc/the-hour-rule-0001
    [3] https://amworkshops.com/tips-techniques/learning-1-of-the-10000-hours-rule/
    [4] https://www.scotthyoung.com/blog/2024/01/23/10000-hr-rule-myth/
    [5] https://www.edsurge.com/news/2020-05-05-researcher-behind-10-000-hour-rule-says-good-teaching-matters-not-just-practice
    [6] https://www.reddit.com/r/TechnoProduction/comments/ttetms/thoughts_on_10000_hour_rule/
    [7] https://www.6seconds.org/2022/06/20/10000-hour-rule/
    [8] https://jamesclear.com/deliberate-practice-strategy

Nice, the copy-response feature in Perplexity is back. Pshwew! I almost switched
to ChatGPT Search there.

Also, interesting the qualifiers it added regarding quality of practice,
complexity of skill and other factors where it included age, genetics and
instruction quality! Very interesting. It only stands to reason, but is worth
noting. 

And that's assuming the very field you're becoming expert in is static, which is
very rarely the case. After 10 years, the field might not even exist in its
original form anymore, so there's a process of continual alignment as you go.

There is perhaps some Platonic ideal out there of having done everything just
the way you want; the grandiose design and vision achieved. But in most ways in
life this just sets you up for disappointment. Lofty goals are allowed, but too
lofty and too far off is demoralizing. The goal-levels need to be set lower and
closer. We need to bank those wins and use the adrenaline, dopamine or whatever
to motivate and drive us onto the next small win.

Something in the short-term will make you, and hopefully those around you that
you need to make happy, happy. You might say that you don't need to make anyone
happy, but that itself is a Platonic idea. We are social animals, each involved
in some social contract. We do this and you get that which you need to live.
Doing this to get that to live is what you need to do to make somebody else
happy. It's not lessening yourself nor compromising. It's paying your dues for
being in the game of life. If you don't like the particulars of your situation,
then you start arranging your short-term wins to directionally move you towards
that longer-term future you want. Still not perfection, but directionally
adjusted to something less objectionable.

A lot of the banking small wins lately and the ability to layer up small wins
one atop another comes from my recent move to NixOS. I say recent, but it's been
a few months now. It's been one of the more ballsy tech moves I've done lately.
We're on Macs at the office, understandably. But every instinct in my body
rejects being on macOS. I am even planning my escape from iOS after all these
years. I've been on it for my phone with just a few stints here and there
because the Samsung Note line was so awesome with its stylus, since 2007. Here
we are in 2024 and I'm planning my extraction and escape from the Apple
ecosystem.

One of the only regrets really is all the apps and media that get "locked up" in
these ecosystems, and thus lock you in; very much by design, and arguably with a
better experience than having to manage all the digital media assets you own for
the rest of your life, through all the uncertainty and churn life brings. Any
particular laptop, server or however else you manage your media may come and go
(e.g. crash) but that cloud infrastructure from Apple, Amazon or whatever is
still going to be there. It's not the worst deal in the world.

The idea then is to strike the right compromise. You don't want to be completely
beholden to these walled garden lock-you-up ecosystems, the pretty prisons as
RMS would put it. But also you don't want to have the entire burden on you to
manage your own digital media and have everything you own and hold dear and
precious at risk of the next flood or whatever act-of-God data-loss is always
happening. So, what's the happy medium? And how do we get there with little
chisel strikes?

Well, under NixOS a humble `configuration.nix` file is going to reproduce
everything except your `home` stuff. That is, all your programs, apps and
whatever else you want to call your software that comes from other people and
mostly doesn't change during the duration of your using it, except for upgrades
and adding plugins and such. It's a static installation for the most part, yet
receives so much of the attention. It's what in the enterprise world is
addressed by Docker images, Kubernetes, complex deployment systems like Ansible
and a host of other overweight, over-complex stuff. If you're not using that
stuff, then you probably know the process as a bunch of `apt`, `yum` or `brew`
commands that you have to run in some order-sensitive fashion to "build" your
system. Under NixOS this is all replaced by `configuration.nix`. And if you're
not on NixOS, then this is all replaced with the `nix` command from within
folders of macOS or Windows (using WSL).

So, problem solved on the "environment build" front. Getting all your apps back
on any hardware you move to is a breeze. It now flows like water. Your default
mode of operation is nomadic, always being on a Noah's Ark of tech ready for any
flood that comes your way. It doesn't feel that way. It just feels like being on
any other Gnome or KDE distro of Linux (a very mainstream Mac/Windows feeling
now) once you're past setup and into just using your apps.

However, the little chisel-strike wins in improving and modifying your system
and work environment after that, the forever-forward banked wins, takes place
(most often) in your `home` directory. That is, the location on Linux known as
`~/`, or in it's expanded-out form as something like `/home/mike/`. And in such
a location, there is another fateful location usually known as `~/.config/`
under which all your per-app customizations are going to reside. Less frequently
these days those customizations might also go in `/etc/`, but for the sake of
banking the biggest wins with the lest effort, we're going to focus on the stuff
in your home directory.

So we're basically talking about backing up data files. A lot of times when you
switch machines and it's not a full ecosystem good-experience-guaranteed
platforms like Apple, or even it is and you just didn't do backups, then there's
this "settling back in" feeling that a lot of people myself included enjoy. But
I'm suggesting this is one of those giant "reset button" events in tech that
sets you back in countless ways.

You want to be able to just point a "ghost image" of your preferred computer
environment, be it for work or your home machine media server or whatever, and
your entire system from apps to data and media files should almost just
magically inhabit whatever hardware you point it at. Your entire system from
apps to data is your own personal cloud spirit that occupies whatever hardware
clothing providence and the state of Moore's Law make possible.

In this way, you are uninterrupted. You are protected against data loss. You are
protected against walled garden ecosystem lock-in. And you are protected against
loss of re-establishing flow-state and getting back to work (or whatever)
quickly due to excessive attention having to be paid to "settling back into" the
new hardware.

However, backing up "home" isn't quite so easy as rebuilding a system's programs
and apps. Programs and apps are just re-fetched from out of whatever
repositories, be it Debain, RPM yum repositories, GitHub, Homebrew or wherever.
In the case of NixOS, it's the Nix repository with most of the individual
packages fetched from GitHub. All this software has version control which can be
"pinned" to whatever version you build your system from (if you want it
deterministic), or allowed to use whatever latest versions if you want to throw
caution to the wind. But that's about as complex and risky as it gets. There's
no real opportunity for data loss the way there is with your unique files.

So of the types of unique data you may possess, if you're a developer then you got a code, and there's gonna be lots of versions of that code. Sooner or later you were going to be directed to in distributed version control system. And probably git in particular. And probably GitHub.com in particular to store those git software repositories Hope you were somewhere offsite, and perchance to collaborate with other people on the code. 

Even if you're not a developer and you do any sort of writing, your face with a similar situation. Let a vendor lock you into their cloud, or if you store it local it's the worst of both worlds: locked into some proprietary vendor file format, and having your local files at risk of data loss. What could be worse than total catastrophic Microsoft Word file loss from a laptop hard drive crash? It's hard to imagine. And so most people by now have been coerced into putting all their data on the cloud.

But what if you were just really good at manipulating text files? What if you did all your fancy formatting with just a simple markup language like Markdown, so that text was enough? In such a world, similar text, editing tools as developers, used for writing code, suddenly become perfectly viable for any writing task, and the methods of doing version control with git are now suddenly open to you. You find yourself in the strongest center of the FOSS (free and open source software) world. There are actual good guys behind you.

One of the biggest fallacies of our time that is widely accepted as truth is that if a product is free, you are the product. FALSE! This is not the case for Linux. This is not the case for the writing environments, you can use under Linux such as vim. And not true for the tools you used to keep your writing safe, such as git. There are really tremendous good guys behind you who are not trying to turn you into a product if you go this route.

Linux Torvalds is behind two of them, Linux and git. The free software foundation, and a host of truly altruistic developer folks are behind the rest. They are not trying to turn you into the product. There is no pop-up advertising. There's no hidden agenda to upgrade you to the paid subscription plan. It's just free as in freedom. Free as in Libre. There are giants here upon whose shoulders we stand. We stand on their shoulders and solidarity against the criminal myth that everything must cost.

Well, there is a cost. The cost is having to provide a little bit of self support because you're not gonna have Apple holding your hand and coddling you along. Likewise, we will also not have Microsoft snooping in on every little key stroke you do to be "helpful". But on the flipside, he will also not have the types of problems that are unique to Apple and Microsoft that keep you having to go to them for support on their own products. You will hit a different set of problems for which Linux is legendary, but also which is getting rapidly fixed through Gnome/KDE polish and NixOS.

All right, so you discover git. You discovered that any folder or directory, whatever you wanna call them, can be turned into a git software repository. That is, all your writing versions can magically get instant undos back to the beginning of time— or at least to the time of you turning it into a git repo. So first you get time travel, however, it is still locked on your local machine and subject to the dangers of hard drive crashes.

The next thing you're gonna discover is that you can easily back up your local git repos to GitHub. You can either make them private or public. The public repos aspect made this website, has its name implies, the hub for much software developer collaboration. In fact, so much so that Microsoft bought it for a cool $8 billion. One of the best deals they ever made. Now they own the heart and soul of the software development community. Everyone keeps their repos on GitHub. Imagine that! Their internal LLMs training on your code. How generous of us. A true case of us being the product. And such a shame, because GitHub started out as such a pillar of FOSS. This strategy is called embrace, extend and eliminate.

And so one of the places we have to take precautions against GitHub and our cloud overlords is to have a local alternative to having to push everything to GitHub. I am not talking about the big back up of your home director yet. That will come later. I am simply talking about having a second place that all your git repos go in addition to, or even as a complete alternative to GitHub. All your repose are not belong to them.

One of the first things you want to make sure you do is keep yourself organized at home. Everything you turned into a git repo, that is every folder or directory in which you type `git init` should probably be inside a single parent folder in home. I like to use `~/repos/` for when I hope is self-explanatory reasons. It's where I keep my repos. By putting it in one location, you will never struggle for that whole "where did I put such and such on my machine?" feeling. You just always go to `~/repos/[folder_name]`, which is a really good feeling. No matter how you switch hardware, this path always is there. Muscle memory for life.

It also has the advantage of putting all your software repositories into the same potential permission context for AI code assists. If anything is truly private, you wanna be careful here. Like if you're using curse or AI and you make repos you are imported folder, I can read anything in there. So be careful. If you still wanna keep private stuff in there like API keys, there are things like `.cursorignore` you can set up. But again, this is all even an issue if you're allowing cloud based LLM's in as coat assistants. If you are doing this on Linux in general and NixOS in particular, you are pretty secure. Way more so than on one of the super-intrusive vendor OSes. 

After you make a new folder in `~/repos/`, and after he typed `git init` to turn it into a git repo, the next thing you're gonna wanna do is set your...

Walk me through the remote origin and point issue here. And also take a look at my configuration.nix and how my local get is set up. Had a paragraph about how you can get hub as your HTTP or SSH protocol based remote origin so that every time you git push it ends up on GitHub and has the security of being offsite. But as an alternative, you can push it locally. You don't even need to be running any special software like a git server. If you're origin is set up as a final system location, you can simply push it there. This could be a good choice for private journals.

```nix
  # Create directory for local Git repositories
  system.activationScripts.createGitRepoDir = {
    text = ''
      mkdir -p /home/username/git-repos
      chown mike:users /home/username/git-repos
    '';
  };
```

Tossing this one over to Advanced:

Gemini: Okay, let's break down the concepts of remote origin and how it applies to your configuration.nix setup, along with considerations for local and remote Git repositories.
Understanding remote origin
In Git, a remote is a pointer to another copy of your repository, usually hosted somewhere else. The origin remote is the default remote that Git creates when you clone a repository. It's essentially a shortcut to the URL of the original repository you cloned from.
 * Why is it important?  remote origin allows you to synchronize your local repository with a remote one. You can fetch changes from the remote (bringing them into your local repo) and push your local changes to the remote.
 * How do you set it?
   * When you clone an existing repository, the origin is automatically set.
   * If you create a new repository, you can add a remote with: git remote add origin <remote_repository_url>
Your configuration.nix and Local Git Setup
Your configuration.nix shows you're well-organized!  You're using NixOS, a powerful Linux distribution that allows declarative system configuration. Here's how your Git setup looks:
 * programs.git.enable = true;:  This enables Git on your system.
 * programs.git.config = { ... };:  You're setting your global Git username and email (used for commits) and your preferred text editor (Neovim).
 * system.activationScripts.createGitRepoDir: This script creates a dedicated directory (/home/username/git-repos) to store your local Git repositories. This is a great practice for organization.
Local vs. GitHub: Choosing Your remote origin
 * GitHub (HTTP or SSH):
   * Pros: Offsite backups, collaboration features, well-established platform.
   * Cons: Potential privacy concerns (especially with public repos), reliance on GitHub's services.
   * How to set it: git remote add origin <github_repo_url> (replace with your actual GitHub repository URL). You can use either the HTTPS or SSH protocol for connecting to GitHub. SSH is generally more secure.
 * Local File System:
   * Pros: Enhanced privacy, no reliance on external services, good for sensitive data like journals.
   * Cons: No inherent collaboration features, requires manual backups to a separate location for true data safety.
   * How to set it: git remote add origin /path/to/your/local/repo (replace with the actual file path).
Example: Setting up a local origin for a private journal
 * Create your journal directory: mkdir -p ~/git-repos/private-journal
 * Initialize a Git repository: cd ~/git-repos/private-journal and git init
 * Create your journal entries (as text files or Markdown).
 * Add and commit your changes: git add . and git commit -m "Initial journal entry"
 * Set up your local remote:  Choose a location outside of your ~/git-repos directory, for example, /mnt/backup/private-journal.  Create that directory if it doesn't exist.
 * Add the remote: git remote add origin /mnt/backup/private-journal
 * Push your changes: git push -u origin main (or master if that's your default branch)
Important Notes
 * Backups: Even with a local origin, you still need a robust backup strategy for your entire system (including your /mnt/backup drive or wherever you store your local remotes) to protect against hard drive failures or other data loss.
 * Privacy with AI code assistants: If you're using AI code assistants that have access to your file system, be mindful of sensitive information in your repositories, even with local remotes. Consider using tools like .cursorignore to exclude specific files or directories.
 * Embrace, Extend, Eliminate: Microsoft's acquisition of GitHub is a classic example of this strategy. While GitHub remains a valuable tool, it's wise to be aware of the potential long-term implications and consider alternatives where appropriate.
Let me know if you have any more questions about setting up your Git remotes or anything else related to your NixOS configuration!

---

All right, so the strategy puts your files with their complete undo history since their creation and at least a second place on your local system. In this example on the same drive, which doesn't do much for diversify the location of the files as a precaution against crashing, but it does set the stage. Whenever you do a git commit and push, it at least puts it in a second location which theoretically could be mapped to a different physical drive. But I say why do that when it creates extra moving parts? 

Why not allow that git push step to always succeed (regardless of what external drives are attached), and then to have a follow up step that synchronizes both your entire repo directory and the git "serverless" server directory? Why not indeed! Your code is now saved in four locations, 2 per physical device. You make the logic that triggers the rsync synchronization robust so that if the external drives not attached, it gracefully fails. 

To some this might seem like not enough. While to others this might seem overkill. To me, it seems like a viable alternative to having everything on GitHub for that even minimal feeling of secure files. This gives you an alternative for things that you do not necessarily want on GitHub, like personal writing or finances. And because of the forever for life nature of NixOS, you are sending the stage for various future passes.

See, this is the one light-touch pass that gives you a 80/20-rule solution. You can start to extend the concept of different origins for your git repos and different rsync actions to back up specific areas of your home directory or your entire home directory in one go.

And I will take this article to the one next pass that I have done to ensure that critical files here and there throughout the system. In particular, I want to be able to edit configuration files quickly. These are those aforementioned `~/.config/[app_name]` files at practice, lifelong assets, like your text editor macros. You've gotta back these up. But they are in these weird locations. Specifically, they are outside the now rigorously and meticulously backed up `~/repos/`

