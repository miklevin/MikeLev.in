---
date: 2023-08-23
title: Planning how MyKoz.AI Introduces Linux Terminal
headline: "I'm Investing in Myself to Change Your Life: Introducing MyKoz.AI and Linux Terminal"
description: Welcome to MyKoz.AI, the site that introduces you to the Linux Terminal and shows you how to use it to stay in your Windows comfort zone. Learn how to use the Linux CLI, Bash Shell, and text editor to keep a personal journal and future-proof your skills. Follow the 2-step transition plan of learning Python through Jupyter Notebook and automating Linux Google Chrome to create a screenshot.
keywords: Linux, Terminal, Windows, Cloud, Python, Vim, Git, LPvg, FOSS, Command-Line, Interface, TTY, Shell, Bash, Jupyter, Notebooks, REPL, Google, Colab, Anaconda, Mount, Home, Directory, Microsoft, Playwright, Automation, Screenshot, Systemd, Daemon, Service, WSL, Symlink
categories: git, microsoft, google, vim, lpvg, systemd, microsoft playwright, wsl, python, linux, jupyter
permalink: /blog/planning-how-mykoz-ai-introduces-linux-terminal/
layout: post
group: blog
---


Hello World. I propose to change your life with this post. I write a lot and
it'll be much to get through, like a Science Fiction short story. But SciFi is
becoming reality all around us every day. And I'm generally spot-on in my
predictions of what's going on in tech and what's becoming important and why.
I'm great at predicting and getting it right. I'm just terrible at benefiting
from being right. But the good news is it's one of those plan-ahead things. If
you're doing the right things now to quite literally invest in yourself, then
when the time comes for you to cash in on having those abilities, you'll
already have them: the right skills in the right place at the right time. Or at
least that's what I'm banking on. But the fact that you're reading this could
be some indication I'm right.

Hello World. Welcome to MyKoz.AI. This site introduces you to an old-school way
of using computers that pre-dates Windows, Mac, Android and iOS. It still lurks
there running everything, unbeknownst to most users. The version of it that's
become mega-popular of late is Linux. Namely, "cloud" versions of Linux run the
servers. We still have our consumer tech like Windows, Macs, Androids and iOS
devices. But we can all feel how there's something else really running the show
these days. And this site provides a way to hop on that Linux runs the world
bandwagon if you're a Windows user and you want to stay in your comfort zone in
regard to desktop OS. If they're to be believed, the stats show that 80% of you
are on Windows machines, either 10 or 11. The rest is Macs, Chromebooks and the
like. But as far as desktop machines go, Windows won.

But the opposite is true on servers. Servers are those amorphous computers out
there in "the cloud" running in datacenters around the world. Sometimes there's
literally dedicated 1-to-1 servers for your apps so that the hardware resources
can be dedicated available full-time to the app, but this is less and less so
as our ability to slice-and-dice computing resources different ways into
dynamically manageable "virtual" computers increases. And with that sort of
shell-game of hardware, so too are software licensing nightmares. This alone is
a strong argument for free and open source software (FOSS). FOSS is part of my
cause, but not the whole story. Or I should say the partial story. For I carve
off a small piece of FOSS called Linux, Python, vim and git (LPvg) and call it
a timeless future-proofing serving of FOSS.

Nobody wants to pay the Windows license to Microsoft for cloud servers when
they don't have to. So let's say you invent some technological thingie. Let's
call it an "app" and let's say it has a service component to the app that runs
on servers. If your app itself is a "web app", then it too runs on servers even
though part of it runs in a web browser on your phones or laptop. If your
application is web-based at all and becomes popular, than you need to scale.
You need more "instances" of your app running on the servers. You need to
***scale*** in the cloud. 

You might thing this ***making an instance*** and ***scaling in the cloud*** is
something for big fancy entrepreneurs or grandiose endeavors. Nope. This is
just how things work now and should be part of everyday literacy. Not even tech
or programming literacy. Just plain literacy. You should not only be able to
understand this stuff in principle, but your schooling should have actually
taught you how to do it as part of the 3 R's: reading, writing and arithmetic.
Even if an AI is there to help you with stuff, you need to speak this language
to know what the heck's going on. Humans still orchestrate, and this is
teaching you how to orchestrate &#151; unencumbered by proprietary licenses.

If your application scales to 1,000 cloud instances, you don't want to have to
pay Microsoft for every instance. You just want to be able to scale your
software. And that's only one of many such examples that lead to the conclusion
that Linux won in the cloud server space, which is big. So to keep your code
cloud-compatible, you're going to want to be Linux-oriented. And you can become
Linux-oriented even while still on Windows. If you have an old Windows 10
laptop lying around, all the better because you can take my favorite course,
which is to to a full PC reset to Windows 10 fresh before starting this
journey.

What journey is that, you say? Well, it's the journey of where you feel most
comfortable and able to do things most immediately, without poking around and
reacquainting yourself with all the specifics of your local environment again.
It's leaving behind the loss of muscle memory between major system upgrades. No
matter how young you are, you probably remember that odd feeling of losing
capabilities when some favorite hardware/software/network platform got retired
because the tech was old and the public moved onto something else. It happens
with game consoles. It happens with phone OSes. It happens on desktop. And
within dominant software like Office and browsers. Platforms change. Interfaces
drift. Capabilities are lost.

MyKoz.AI is to fight that capability-loss by replatforming you onto something
nearly eternal, called the command-line interface (or CLI). Some cringe at that
name for it's super-generality and would correct you to say that it is the
Linux Terminal or Shell we're talking about. Either of those are just another
way of saying that type-in user interface that computers have had for a very
long time, because dealing with just text takes a lot less processing power
than doing everything with graphics. You'd think text is graphics, but in many
ways it is not. Looking at text on the screen obviously was converted to
graphics for the user interface, but somewhere down there, it's just
represented as plain text that maps to traditionally 25 vertical lines and 80
characters across. That was a popular text user-interface standard for awhile.

Text interfaces continue today in many forms. Windows has the Command Prompt, a
carry-over from the days of DOS, an early text-based form of the PC operating
system. It was the part that was legendarily bought by IBM from Bill Gates and
a very early Microsoft. That was the big break, making the operating system of
PCs MS-DOS. There's a few other traditions of text-based OSes that go way back
like CP/M, the other major contender to DOS for the home computer market in
those days. 

UNIX did exist by then, but it was both proprietary, meaning the intellectual
property of AT&T, and it was big in terms of system requirements. Home and
personal computer OSes needed to be much smaller than UNIX back in those days.
And so today we have something like DOS in Command Prompts, and another
command-line language in a different program called PowerShell. And so both
Command Prompt and PowerShell are built into Windows. And you don't want to use
either. They're non-Linux dead ends. You want to learn genuine cloud-like
Linux.

And so that's what MyKoz.AI is all about. Without giving up the Windows
desktop, I'll help get you onto Linux in spirit. Spirit being the use of the
Linux CLI known as the Linux Terminal. Some might call it the Linux Shell. And
others still might call it a Bash Shell, because of splitting hairs over
precisely what "flavor" of command-line interface we're talking about. And yes,
it probably is every bit as boring as it sounds. But the text editor isn't. You
can start using the text editor to keep a personal journal in a single textfile
for the rest of your life.

If this still all sounds confusing, understand that typing as a way of
communicating with computers wasn't immediately obvious. But type-writing as a
way of communication was happening there in the early days even before digital.
Analog phone-lines were used to transmit typewriter commands over the phone
system. They called it teletype. And there were teletype machines. Early on in
computers, this teletype protocol, or TTY, was used to communicate with
computers. And so the command-line interface is also called the TTY interface.
You'll find or hear of software called things line PuTTY or MinTTY. That's
where the TTY comes from. The devices which were like typing-phones were called
Teletype Terminals. Or TTY Terminals. And today's Linux Terminal is actually a
TTY interface. 

More or less confusing? Okay, so there's a long history here. The Unix and
Linux typing interface are TTY-based. The MS-DOS one is not. TTY was a protocol
born in another industry and refined for its efficiency back in the days when
every keystroke cost something. But it was still a bare-bones interface. It was
not enough to change directories and have a command-recall history so you
didn't have to retype everything you typed recently. And for that, people wrote
software-enhanced versions of the TTY interface. They were "shells" that
enveloped the TTY interface. And so the TTY interface is also called the
"shell". And the most popular shell is called the "Bourne Again Shell" or
"bash". And so the Linux Terminal is also called the "bash shell".

So if Linux is so big and it's free, why doesn't Microsoft just include it with
Windows so that the Windows platform stays relevant for developers and
developers can have an easier time learning Linux? Well, they did. Few people
know it, and fewer people still are using it as a way of navigating off of
Windows. By shifting your main "base of operations" on your desktop computer
from being the graphical operating system to being a full-screen Linux
text-editor, you can begin to learn Linux without giving up Windows. 

And as you learn Linux, you are switching your day-to-day operations over to
this timeless future-proofing stuff, so that over time if you were faced with
the choice of ditching Windows or ditching Linux, the choice will be clear.
Ditch Windows. Graphical UIs are a dime a dozen. Choose whichever one you like
and you think will be around the longest if you're investing any muscle memory
into graphical apps. But that's all secondary to the fact you're now a vim
wizard and can edit any text-file anywhere. Linux is your new home.

This happens through a 2-step transition plan. The first part of the plan is
learning Python through Jupyter Notebooks. That is, specifically through
JupyterLab. JupyterLab is a graphical interface to Jupyter Notebooks which runs
in your Web browser. It's a widely beloved interface for learning Python
amongst data scientists and students. The thing that makes it special is how
documentation and code can be mixed together in a single document. Also, the
code runs in this suspended code-as-you-go fashion. It's sometimes called a
REPL (read-evaluate-print-loop). It's a way of running code in a way that
allows you to see the results of each line of code as you go, which is
tremendously useful for learning. The documentation, REPL and browser all come
together for a very not too scary way of learning Python. 

Now when most people go the Notebook route, they're guided into using a
notebook service like Google Colab. Or if they're running it locally, they'll
use a tool like Anaconda. Each of these approaches will work but have their
drawbacks. Google Colab is a great service, but it's not your computer. You
can't necessarily install anything you want, and you can't do things like
automate web browsers or other things that specifically tap into your computer.
It seems like a convenience at first, but it cuts off many of the timelessness
and future-proofing benefits of your local computer. And Anaconda which does
install Jupyter locally is a Windows program. And so it's Python under Windows,
which again defeats the point of using Linux for future-proofing. What you
really want is the Linux version of Python running locally on your Windows
computer. That's the most obvious surface benefit of MyKoz.AI. 

It's a lot to ask a person to delve into the Linux Terminal, jumping right to
keeping a 1-file daily journal for life. I mean we'll get there, and that's
ultimately maybe even more important than this whole Linux Python thing. But
Linux Python leads you to Linux Terminal, is what I'm saying. You're going to
***want*** to use the Linux Terminal when you get done seeing what I have in
store for you.

Hmmm. I clearly want to go from Jupyter Notebook to a filename.py file, which
JupyterLab is perfectly capable of exporting. However, it automatically drops
it into your browser's Download directory which is not so easy to get to from
the Linux side. It's there, but through this long convoluted path. However, I
can just ***mount*** that location in the ***home*** directory!

Okay, I have a MyKoz test install running now to see if I've linked in the
Download directory properly. The exercise will be going from something very
basic in a Jupyter Notebook to a filename.py file in the Linux Terminal. And
that filename.py will probably be yourservice.py located in the
`~/repos/yourservice` repo folder MyKoz clones out of Github for you. Okay, so
if the Download directory is really linked in from `~/Downloads` after this
test, then the rest of the path the MyKoz.AI soft launch is clear.

We want the simplest possible Microsoft Playwright automation of Linux Google
Chrome to create a screenshot. That's it. That will be the Linux systemd daemon
service I'll have pre-running. I don't want to tank the performance of the WSL
instance of having it do that too often. Maybe I'll make it do it twice per
day. But then it will also do it once immediately after the service is started,
and so a great way to test is just to restart the service. But otherwise, I'll
put scheduling in place. Yeah, so the service will run a Python script as a
full-time 24x7 service, but that service will a Python script that has
implemented scheduling. And one of the items it has scheduled is the screenshot
automation.

Okay, the symlink to make the Windows Downloads directory in the Linux Ubuntu
home folder was successful. However, it is not accessible under JupyterLab,
which would be the most convenient way to put it in location. I ***could*** map
the Downloads folder under `~/repos/` so that it would be a file-copy operation
under JupyterLab to turn it into a service. However I should probably use it as
the excuse to get people into the Linux Terminal and writing a `cp` command. So
I'll just have them copy the file from the Downloads directory under
`~/Downloads` to the `~/repos/yourservice` repo folder.

Well this is really interesting. I'm designing the experience, really. Hmmm.
Maybe I want to keep that while-loop thing in there that just does a datetime
command every 5 seconds as the default. That way I can build the every-N timing
into the screenshot automation. It can do once right away when it's run to test
the service, and then it can do once every 12 hours. That's a good default. And
then I can have the user change it to whatever they want. And I don't have to
get into the multiple-file thing with a parent Python scheduling app. That will
surely come later. But MyKoz.AI will evolve now in public from these "MVPs"
(minimal viable products).

Okay, so the next step is that minimal Chrome automation from Playwright thing.











<div class="arrow-links"><div class="post-nav-prev"><span class="arrow">&larr;&nbsp;</span><a href="/blog/optimists-are-objectively-correct-while-pessimism-is-100-faith-based/">Optimists are Objectively Correct while Pessimism Is 100% Faith-Based</a></div> &nbsp; <div class="post-nav-next"><a href="/blog/going-back-to-windows-10-from-windows-11/">Going Back to Windows 10 From Windows 11</a><span class="arrow">&nbsp;&rarr;</span></div></div>
## Categories

<ul>
<li><h4><a href='/git/'>Git</a></h4></li>
<li><h4><a href='/microsoft/'>Microsoft</a></h4></li>
<li><h4><a href='/google/'>Google</a></h4></li>
<li><h4><a href='/vim/'>Vim</a></h4></li>
<li><h4><a href='/lpvg/'>LPvg</a></h4></li>
<li><h4><a href='/systemd/'>Systemd</a></h4></li>
<li><h4><a href='/microsoft-playwright/'>Microsoft Playwright</a></h4></li>
<li><h4><a href='/wsl/'>WSL</a></h4></li>
<li><h4><a href='/python/'>Python</a></h4></li>
<li><h4><a href='/linux/'>Linux</a></h4></li>
<li><h4><a href='/jupyter/'>Jupyter</a></h4></li></ul>