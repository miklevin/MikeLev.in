---
date: 2023-09-05
title: Internalizing the Tools of Your Trade That are Timeless to Boot
headline: I Internalized the Tools of My Trade - and They're Timeless!
description: I'm a firm believer in learning the timeless tools of your trade, rather than relying on high-dependency power-tools. My journey through coding languages has led me to appreciate the advantages of Python, which is now the lingua franca of tech. I've also come to understand the importance of learning to code in a text editor, like Vim, that is not subject to the whims of its creator. Empower yourself by internalizing the tools of your trade that are timeless to boot.
keywords: date, Tue, Sep, 05, 2023, Internalizing, Tools, Trade, Timeless, Boot, Capable, Lately, Expression, High-Dependency, Power-Tools, Do-It-The-Hard-Way, Material, Rewards, Spiritual, Pre-Proprietary, Baseline, Abilities, Shortcuts, Cheats, VSCode, Microsoft, Web App, Chrome, Apple, Webkit, Browser, Rendering, Engine, Giants, Mot
categories: microsoft
permalink: /blog/internalizing-the-tools-of-your-trade-that-are-timeless-to-boot/
layout: post
group: blog
---


What are you capable of doing and what have you done lately? This is an
expression I heard ages ago and it has always stuck with me. At those times
when I had to learn how to do a thing and there were 2 routes: one with
high-dependency power-tools (but the job gets done faster) versus the
do-it-the-hard-way which takes longer but you come away with a deeper
understanding and fewer dependencies, I usually did things the harder way. The
material rewards have been much lower, but the spiritual ones have been through
the roof. I feel better about myself because those dependencies are me.

Let's talk about pre-proprietary baseline abilities. Sure, you're always going
to take up and use power-tools in whatever field or interest you get into. Who
doesn't like shortcuts and cheats to appear to know more and do better than
what you're capable of with your very own hands? In the world of coding, VSCode
plays that role today. It's from Microsoft. It's a "web app" built on
components from the free and open source version of Google Chrome, which in
turn were built from Apple's own free and open source Webkit browser rendering
engine. So that's 3 levels of big-tech dependency right there... just to edit
text.

Few things in the world of tech right no are quite as perfectly symbolic of
heavyweight dependency as VSCode. Sure, we all stand on the shoulders of giants
for our tools and to get our work done. Almost none of us burn our computers
from sand anymore, but subtlety and nuance matter. On exactly which giants
shoulders do you stand and what are their motivations? To necessarily have a
full web stack in the picture to edit text, and to further develop dependencies
on live online services that are subject to change or going away at any time
turns a mere rent-to-own dependency dynamic into feeding at the teats. What are
you going to do if the mother's milk of AI-driven autocompletion or some other
aspect of the product gets cut off or suddenly very expensive?

The answer is you double-down on that dependency. You defend the vendor for
their shenanigans and if it becomes too expensive, you hope that your employer
pays for it for you. You are dependent on the feed and will do whatever it
takes to keep getting the fix, and thereby not lose abilities you only have
through "external" means. Vendor-provided abilities.

Shortcuts are nice. Power-tools and magic wands have their place. Produce great
work fast. No doubt, output is output. But that is the trap. Dependency is a
tricky thing. The concept of "slippery slope" and "the domino effect" are often
dismissed as fallacies, and they often are. Except when they're not. There's a
certain depth-of-hole dependency-wise you can dig yourself into that you can't
so easily escape. 

Once when you realize you're in that deeply-dug proprietary hole, the prospect
of learning (internalizing) the free and open source tools (FOSS) that would
let you dig yourself out seems excessively challenging and demoralizing. So the
sooner you take up those FOSS alternatives as your old-school toolbox, the
better. There are other giants upon whose shoulders you can stand. And because
power-tools are so easy to take up later, it's never all-or-nothing. It's just
that the order of operations matters. Old-school first. Power-tools second.
Stand on the shoulders of whichever giants you want. Simple as that.

It's worth pointing out that the equivalent of VSCode in our everyday lives is
our phones and mobile platforms in general. These mobile platforms don't make
available the old-school tools so easily because of their deeply "consumer"
orientation and how most software gets loaded through tightly vendor-controlled
***App Stores.***. While this was appropriate and necessary back in the day to
keep the viruses and trojans that plagued desktops back in those days at bay,
it has also shaped the mobile platforms into anti-agency agents. Free and open
source software is agency and proprietary is anti-agency. And by that I mean
free-will and your ability to think for yourself without undue influence.

This point needs a bit of clarification. The system by which our tools
operation help define us. We are in part what our tools "let" us do. Think
about languages. Language is a tool like any other, except for that fact that
it gets uniquely ***internalized*** into our bodies and interleaved with our
very ability to articulate our thoughts. Sure, we can have thoughts without
language, but the moment we begin to clarify them for ourselves by thinking out
loud or encoding it into words in any way, our thoughts shift and transform
into something where all the strange shaped pegs fit into the 26 square and
round shaped holes in the English alphabet. All tools are like that.

We shape our tools and our tools shape us. Lather, rinse and repeat across the
the generations of a society or the years of your life. In either case,
hopefully you get the idea. We think many of the thoughts we have, and thus do
many of the things we do because our language makes those particular things
easier to think, visualize, and thus do. Certain concepts are easier to express
in certain languages. This is called the linguistic relativity hypothesis and
does have its controversy. You'll often here there was no word for the colors
blue or orange until modern days or that Eskimos have more words for snow. It's
not so clear cut, but the fact is that there are subtleties and nuance about
which you ought to be aware regarding language or any other tool. Without
knowing that the tools exist in certain states for certain purposes is to give
up part of your essential self which might get lost in translation.

So we do the best we can with the tools we're given. Some people deliberately
become multilingual to try to become better people, to experience more and to
have a deeper understanding of who their essential self is and what they're
about. My success along these lines with spoken languages has led to less than
fluency in Spanish and Japanese, but I have a deep appreciation for the
languages and cultures. I have a deep appreciation for the people who speak
them and the cultures they come from. But it was never tied to my day-to-day
life enough to become fluent. I'm not a spoken-language polyglot.

Ahhh, but ***other language tools*** I have had more luck with. Or maybe not
luck. Maybe it was just persistence and tenacity. I was a bit of a purist
because my job was never specifically programming, I got to give up what I
didn't like and move onto more appealing things. Thankfully as not being a
professional programmer, I have not ***had to*** stick to this language or
that, so its given me a chance to hop around over the years sampling a lot. In
the early days of the Web, we're talking before the turn of the century, I took
up the O'Reilly camel book and learned PERL. I did a few websites on Perl and
understood cgi-bin and the like. As time moved on I dabbled in ***tickle***
(TCL). 

Years earlier (the 80s), I was even a classic BASIC programmer and took my hand
at C. This was before C+ or C++. And time and time again I re-tried taking up C
given its seemingly essential nature. It's a similar story with JavaScript,
both before and after its explosive popularity growth when NodeJS came out to
make it a server-side language ***again.*** Yes, JavaScript was on the server
before ***several times.*** And of course there was Java whose ***write once,
run anywhere*** pitch resonated with me and motivated me until my mind went
numb trying to learn it. I just couldn't get into Java and all those languages
derived too closely from C.

Around the turn of the century when Ruby on Rails came out, I took up Ruby. I
could go on with how I sampled this and that, but long story short, there was
very little love in it until I found Python. Python was and is a
***love-worthy*** language.

Obviously the world agrees with me as the popularity of Python is time and time
again surpassing all other languages when choice is a factor. If you get to
choose your language, you generally choose Python. It's easy to learn, tied to
nearly every industry, and has a huge ecosystem of libraries and frameworks,
and grows with you as you become more advanced. When you hit the limits of
Python, there are tons of ways to integrate it with other languages and make it
the overarching glue that holds your project together. Build this in R or that
in Rust, but the glue that holds it all together is Python. It's a trend you'll
find all over the place.

The final thing to realize about Python, and part of what's been driving its
popularity, is that its a true free and open source language. You can go as far
as to say that everything everyone refers to as Python isn't really even the
one true Python. It's just the particularly popular implementation of Python
based on the specification. It is what you would call the "reference
implementation" of Python. It's often called CPython, or the version of Python
that was written in the C-language, originally by Python's creator Guido van
Rossum, but later taken over by Python.org and the Python Software Foundation.
CPython itself exists in many forms for different platforms such as Windows,
Mac and Linux. Guido has since stepped down as the "benevolent dictator for
life" and Python is now run by a committee of sorts, demonstrating its ability
to just keep going on through any crisis and it's "too big to fail" nature.

There are plenty of other implementations of Python too. They go off in wild
directions like being as small as possible to embed into products or being as
fast as possible to run on microcontrollers. There's even a Python that
transpiles to JavaScript so you can run Python in the browser. And more and
more often Python is built into other software products to provide a familiar
interface for automating them, such as Blender, InkScape, GIMP and FreeCAD.
This covers graphics from 2D to 3D, from pixels to vectors, from movies to
physical products. Python is in space, on Mars, and in the International Space
Station. It's in the cloud, on the desktop. It's even one of the driving forces
behind AI, as most of the popular AI frameworks are written in Python. 

Did I mention that Python was the lingua franca of tech? Ponder for a moment
what it means for you to be Python literate. It's an endeavor that only takes a
few moments to get started, but could change your life forever. It's a path to
multilingualism that finally worked for me, and I think is more accessible than
spoken languages in general. It rounds you out as a personality if spoken
languages aren't really your thing, and you're looking for something more
precise and reliable than the spoken word.

So does learning Python mean that you are ***tech literate?*** Does it mean
that you are fluent in the language of automation? It's more and more true
every day. And it's mostly just Python. While there are other languages that
will fit in, they will be the exception and not the rule. When you expand the
focus to see what other technologies ***must still be in the picture,*** it
really comes down to a place to run your code that doesn't have you in that
exact same dependency trap as VSCode and your phone. You need a place to run
your code that is ***yours*** and not subject to the whims of a vendor. And it
should be a stable and unchanging enough platform that you don't have to
relearn everything every few years just to keep your code running. And that
means Linux. It means learning just enough Linux to get and keep your Python
code running.

And of course you need to write your code in the first place. VSCode? Hahaha!
Yeah, maybe ***after*** you've protected yourself against vendor lock-in and
dependency. But for now, you need to learn to code in a text editor. Some will
try to guide you towards this proprietary text-editor or that. But google-up
the stories of TextMate, Sublime and Atom. Three beloved text editors that
became proprietary and then were abandoned by their creators. The community
stepped in to keep them going, but the lesson is clear. You want to learn to
code in a text editor that is ***timeless*** and not subject to the whims of
the creator. And that means Vim.

It could also mean eMacs for some particularly wizardly types, but Vim is
simpler and more accessible. It's precursor vi is built into every Linux
distribution and is the only editor you can count on being there. So the path
I'm leading you down is one of being able to sit down at almost any computer
in almost any situation and being able to take command of that system. You are
dependent on nothing but your own knowledge and skills. You are not dependent
on any vendor. You are not dependent on plug-ins or power-tools. You have
completely internalized the tools of your trade, which are timeless to boot.











<div class="arrow-links"><div class="post-nav-prev"><span class="arrow">&larr;&nbsp;</span><a href="/blog/coding-keyboards-and-literacy/">Coding, Keyboards and Literacy</a></div> &nbsp; <div class="post-nav-next"><a href=""></a></div></div>
## Categories

<ul>
<li><h4><a href='/microsoft/'>Microsoft</a></h4></li></ul>